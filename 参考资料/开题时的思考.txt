输入：一些函数以及它们的输入参数的取值范围。
输出：它们的返回值（好像一定是int？？？）的取值范围。

1、解析SSA文件。SSA没有成文的语法规定，这就很迷，只能从10个样例中总结了。
每个函数的形式：
	;; Function 函数名 (函数名, funcdef_no=y, decl_uid=x, cgraph_uid=y, symbol_order=y)
	函数名 ((type var)*) 可能没有参数；参数似乎不可能是指针和引用
	{
		declare_stmt*
		(LABEL stmt* 跳转语句?)* 
		RETURN_LABEL 返回语句
	}

type：
	var类型，可能是int或float
LABEL：一个基本块开头的label
	<bb x>:
RETURN_LABEL：最后一个返回的基本块开头的label
	<Lx>:

declare_stmt：
	定义的同时不会赋初值。type为int或float
	1、定义的var可能是局部var，不带版本号
	2、也可能是_版本号。表示中间运算结果和返回值。
	3、还可能是D.x：似乎不用管。

stmt有如下几种可能。用正则表达式匹配每个语句吧。
1、赋值语句：var = 表达式
	表达式的类型：
	1、量
		量的类型：
		1、var
			var的类型：
			1、var名_版本号，var名可以是局部var或参数。
				参数可能有一个初始的取值范围，取值范围可以是空！！！
			2、_版本号，认为var名是空吧。会有一个这样的var专用于返回值
			注意，版本号是不会冲突的！！！

			var后面还可能带(D)
			表示这个块中至今为止没有给这个var赋值，而是采用它（一定是参数）的初值
		2、常量，可以是科学计数法
	2、量 运算 量 好像不会出现连续运算。运算是+ - * / 还有 < <= > >= == !=
	3、(type) 量 强制类型转换
	4、函数(量1，量2……)。函数之间会不会递归调用？？？
2、表达式，似乎只可能是函数。
	反正也不会传指针，空算一个表达式没有任何意义。
3、# var = PHI <var1(x1), var2(x2)> 注意，后面没有分号
	x表示从哪个块而来。所以在实际进行跳转时，要记录从哪个块而来。

跳转语句：
	0、不出现。默认跳转到bb x+1或者最后的L。
	1、goto LABEL (RETURN_LABEL?)
	2、if (表达式) goto LABEL (RETURN_LABEL?)
	else (比较表达式) goto LABEL (RETURN_LABEL?)
	可能有一个RETURN_LABEL，不要管了……	
	if似乎只会在这里出现
	关于比较的表达式似乎只会出现在if中？？？要不要把它们分开来呢？？？
	if < ：让两个范围取交集，如果非空则可能走这条路！！！

返回语句：
	return 变量?
	变量一定是_版本号。
	注意，可能只有一个return 但没有返回值，默认返回值是0吗？？？

2、对每个函数构造控制流图（CFG）
	有一个总入口ENTRY 进入<bb 2>
	一个块可能来自1或2（循环回边）个父节点，但是不用记录父节点。
	一个块可能去往1或2（if分支）个子节点
	有一个总出口EXIT 从<Lx>而来

——————————————————————————————————————————————————————————

3、怎样进行数据流分析：paper部分
定义格Z = -inf 并 Z 并 inf
在上面做一个“稀疏分析”？？？

“首先，我们将程序转换为一个“表示”（representation），为我们提供补贴以执行稀疏分析。 
	就是C代码转SSA
其次，我们从程序表示中提取约束。 
	就是把SSA分成基本块和其中的语句。
第三，我们根据Su和Wagner [25]指出的策略建立一个约束图。 
	然而，与他们相反，在下一个阶段中，我们在这个图中找到强连通分量（就是循环和递归调用吧？），
	将它们折叠成超节点，并对结果图进行拓扑排序。
	
	类似于解读出基本块之间的跳转关系，构建成图
	存在控制流图（基本块之间）和数据流图（paper中给出的那种图）
最后，对于每个强连通分量，我们应用三阶段方法来确定变量的范围。”
	注意，把一个强连通子图作为一个基本单位，解析其中每个变量的范围！！！

	将强连通子图收缩（collapse）成一个节点？？？
	“我们算法的所有复杂性都在于解决强连通子图的问题。
	大部分的强连通子图只有一个节点、有多个节点的话个数也不会多。”
	重头戏！

约束图中，C是约束（就是程序中的赋值语句！！！）顶点、V是变量顶点
	若C中useV，则连边V->C
	若C中defV，则连边C->V
	这是一个C和V的二部图。构造约束图

特殊的控制依赖边的问题？？？control dependence，作为虚线边

对于一个强连通子图的三阶段方法
1、扩展（widening）
	在一个强连通子图中，抽象地解读其中的约束，发现变量的growth pattern
	比如一直 += 正数，或者 += 负数
	扩展操作可以确保程序结束————
	我觉得是说，一个循环如果做了很多次发现一直一直的增长，就直接一步到位成无穷。
	从别的块进这个循环以后，直接套用结果、出循环。
	“如果我们使用上面的加宽算子，那么任何约束变量的抽象状态只能改变三次，例如[⊥，⊥]→[c1，c2]→[c1，∞]→[-∞，∞]或[⊥，⊥]→[c1，c2]→[-∞，c2]→[-∞，∞]。”
	这这这，这科学么？？？
	比如 k=0 while k<100 k++，这个是怎么模拟出来的？？？
	后面还有一步narrowing呢。


2、用实际限制来取代future bound
3、从condition tests开始收缩（narrowing），提高结果的精确度

	每个约束I，求出对应的e
	widening：根据I和e的值，更新I
	future：填上ft这样的空
	narrowing：根据I和e的值，更新I